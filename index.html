<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="utf-8" />
    <title>Portfolio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
  </head>
  <body>
    <script>
      // Renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      // ✅ สีตรง/ภาพคมขึ้น
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      // Camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(18, 72, 1);
      camera.lookAt(18, 72, 36);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enablePan = false;
      controls.minDistance = 5;
      controls.maxDistance = 300;
      controls.maxPolarAngle = Math.PI / 2; // ไม่ให้หมุนลอดพื้น
      controls.target.set(18, 72, 36);
      controls.update();

      // Light
      scene.add(new THREE.AmbientLight(0x808080));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(20, 20, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 1024;
      dirLight.shadow.mapSize.height = 1024;
      dirLight.shadow.camera.left = -50;
      dirLight.shadow.camera.right = 50;
      dirLight.shadow.camera.top = 50;
      dirLight.shadow.camera.bottom = -50;
      dirLight.shadow.camera.near = 1;
      dirLight.shadow.camera.far = 100;
      scene.add(dirLight);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 300),
        new THREE.MeshStandardMaterial({
          color: 0x228b22,
          roughness: 0.9,
          metalness: 0.1,
        })
      );

      // >>> เพิ่ม 4 บรรทัดนี้ <<<
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const hoverTargets = []; // เก็บ root ของโมเดลที่ให้ hover
      let hoveredRoot = null;

      // อัปเดตตำแหน่งเมาส์
      renderer.domElement.addEventListener("mousemove", (e) => {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      });

      // ออกจากแคนวาสให้ยกเลิกไฮไลท์
      renderer.domElement.addEventListener("mouseleave", () => {
        if (hoveredRoot) {
          hoveredRoot.traverse((o) => {
            if (o.isMesh && o.material && o.userData.baseColor) {
              o.material.color.copy(o.userData.baseColor);
            }
          });
          hoveredRoot = null;
        }
      });
      const clickTargets = []; // เก็บ root ที่ "คลิกได้"
      let aboutmeRoot = null;
      let PBRRoot = null;
      let backRoot = null;
      let back1Root = null;

      // เป้าหมายตำแหน่งกล้องและจุดที่อยากให้มอง
      const camTargetPos = new THREE.Vector3();
      const camTargetLook = new THREE.Vector3();
      let camLerping = false;

      // คลิกเพื่อย้ายกล้อง
      renderer.domElement.addEventListener("click", () => {
        // ใช้ตำแหน่งเมาส์ที่อัปเดตจาก mousemove
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(clickTargets, true);
        if (!hits.length) return;

        // หา root ที่อยู่ใน clickTargets
        let node = hits[0].object,
          root = null;
        while (node) {
          if (clickTargets.includes(node)) {
            root = node;
            break;
          }
          node = node.parent;
        }
        if (!root) return;
        if (root === aboutmeRoot) {
          // เข้าไปใกล้ aboutme แล้ว "มองไปที่ PBR"
          camTargetPos.set(18, 70, -3);
          camTargetLook.set(-13, 70, -2);
        } else if (root === PBRRoot) {
          // เข้าใกล้ PBR แล้ว "มองไปที่ aboutme"
          camTargetPos.set(65, 62, -100);
          camTargetLook.set(37, 62, -96);
        } else if (root === backRoot) {
          // ไปแถว back แล้ว "มองไปที่ back1"
          camTargetPos.set(18, 72, 1);
          camTargetLook.set(18, 72, 36);
        } else if (root === back1Root) {
          // ไปใกล้ back1 แล้ว "มองไปที่ back"
          camTargetPos.set(18, 72, 1);
          camTargetLook.set(18, 72, 36);
        } else {
          return;
        }

        camLerping = true; // เริ่มเลื่อนกล้อง
      });

      let ku = null;
      let icecream = null;
      let pbrballglb = null;

      // GLTF/GLB
      const draco = new THREE.DRACOLoader();
      draco.setDecoderPath(
        "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/"
      );
      const loader = new THREE.GLTFLoader();
      loader.setDRACOLoader(draco);

      // model1
      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/cloud.glb",
        (gltf) => {
          const cloud = gltf.scene;
          cloud.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          cloud.position.set(1, 1, 1);
          cloud.scale.set(1, 1, 1);
          scene.add(cloud);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // model2
      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/shopp.glb",
        (gltf) => {
          const shopp = gltf.scene;
          shopp.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          shopp.position.set(22, 0, 1.5);
          shopp.scale.set(20, 20, 20);
          scene.add(shopp);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/icecream.glb",
        (gltf) => {
          icecream = gltf.scene;
          icecream.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          icecream.position.set(92, 15, 44);
          icecream.scale.set(5, 5, 5);
          icecream.rotation.y = THREE.MathUtils.degToRad(80);
          scene.add(icecream);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/ku.glb",
        (gltf) => {
          ku = gltf.scene;
          ku.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          ku.position.set(-7, 67, 34);
          ku.scale.set(5, 5, 5);
          ku.rotation.y = THREE.MathUtils.degToRad(120);
          scene.add(ku);
          ku.userData.baseY = ku.position.y;
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // aboutme
      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/aboutme.glb",
        (gltf) => {
          const aboutme = gltf.scene;
          aboutme.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          aboutme.position.set(7, 82, 40);
          aboutme.scale.set(5, 5, 5);
          aboutme.rotation.y = THREE.MathUtils.degToRad(180);
          scene.add(aboutme);
          hoverTargets.push(aboutme);
          clickTargets.push(aboutme);
          aboutmeRoot = aboutme;
          aboutme.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.userData.baseColor = o.material.color.clone();
            }
          });
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );
      // PBR
      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/PBR.glb",
        (gltf) => {
          const PBR = gltf.scene;
          PBR.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          PBR.position.set(5, 76, 39);
          PBR.scale.set(6, 6, 6);
          PBR.rotation.y = THREE.MathUtils.degToRad(90);
          scene.add(PBR);
          hoverTargets.push(PBR);
          clickTargets.push(PBR);
          PBRRoot = PBR;
          PBR.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.userData.baseColor = o.material.color.clone();
            }
          });
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // PBR
      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/pbrballglb.glb",
        (gltf) => {
          pbrballglb = gltf.scene;
          pbrballglb.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          pbrballglb.position.set(29, 64, -90);
          pbrballglb.scale.set(6, 6, 6);
          pbrballglb.rotation.y = THREE.MathUtils.degToRad(90);
          scene.add(pbrballglb);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/back.glb",
        (gltf) => {
          const back = gltf.scene;
          back.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          back.position.set(-15, 48, 3);
          back.scale.set(6, 6, 6);
          back.rotation.y = THREE.MathUtils.degToRad(1);
          scene.add(back);
          hoverTargets.push(back);
          clickTargets.push(back);
          backRoot = back;
          back.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.userData.baseColor = o.material.color.clone();
            }
          });
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      loader.load(
        "https://eyepps09-source.github.io/portfolio_pe/models/back1.glb",
        (gltf) => {
          const back1 = gltf.scene;
          back1.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          back1.position.set(29, 45, -84);
          back1.scale.set(6, 6, 6);
          back1.rotation.y = THREE.MathUtils.degToRad(1);
          scene.add(back1);
          hoverTargets.push(back1);
          clickTargets.push(back1);
          back1Root = back1;
          back1.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.userData.baseColor = o.material.color.clone();
            }
          });
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // Loop
      (function animate() {
        requestAnimationFrame(animate);

        // หมุนโมเดลบางตัว
        if (pbrballglb) pbrballglb.rotation.y += 0.005;
        if (icecream) icecream.rotation.y += 0.005;

        // Hover (ชมพู)
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(hoverTargets, true);
        let newHover = null;
        if (hits.length) {
          let node = hits[0].object;
          while (node && !hoverTargets.includes(node)) node = node.parent;
          newHover = node || null;
        }
        if (newHover !== hoveredRoot) {
          if (hoveredRoot)
            hoveredRoot.traverse((o) => {
              if (o.isMesh && o.material && o.userData.baseColor) {
                o.material.color.copy(o.userData.baseColor);
              }
            });
          hoveredRoot = newHover;
          if (hoveredRoot)
            hoveredRoot.traverse((o) => {
              if (o.isMesh && o.material && o.material.color) {
                o.material.color.set(0xff69b4);
              }
            });
        }

        // Lerp กล้องด้วย OrbitControls
        if (camLerping) {
          camera.position.lerp(camTargetPos, 0.08);
          controls.target.lerp(camTargetLook, 0.08);
          controls.update();
          if (
            camera.position.distanceTo(camTargetPos) < 0.05 &&
            controls.target.distanceTo(camTargetLook) < 0.05
          ) {
            camera.position.copy(camTargetPos);
            controls.target.copy(camTargetLook);
            controls.update();
            camLerping = false;
          }
        }

        // ku ลอย
        if (ku) {
          const t = performance.now() * 0.001;
          ku.position.y = ku.userData.baseY + Math.sin(t * 2.0) * 0.5;
        }

        controls.update();
        renderer.render(scene, camera);
      })();

      // --- Responsive Resize ---
      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.setPixelRatio(window.devicePixelRatio || 1);
      });
    </script>
  </body>
</html>
